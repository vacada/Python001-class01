# week07笔记

+ 新式类和经典类
	当前类或者父类继承了object类，那么该类就是新式类，否则便是经典类
	新式类继承采用广度优先，经典类继承采用深度优先
	mro()可以分析继承顺序
+ object类和type的关系
	+ object和type都属于type类（class 'type')
	+ type类由type元类自身创建的，object类是由元类type创建
	+ obejct的父类为空，没有继承任何类
	+ type的父类是object类（class 'obejct')
+ 类的静态字段和普通字段
+ 为类添加属性
	+ 类名.属性名
	+ setsttr(类名，字段名，字段值)
	+ 内置类型不能添加属性和方法
+ 类的三种方法
	+ 普通方法
	+ 类方法
	+ 静态方法
+ 构造方法和初始化方法
+ 描述器
	+ 使用场景：在类中，需要对实例获取属性这一行为进行操作
	+ \_\_getattribute\_\_()和\_\_getattr\_\_()异同
		+ 都可以对实例属性进行拦截
		+ \_\_getattr\_\_()适用于未定义的属性
		+ \_\_getattribute\_\_()对所有属性的访问都会调用该方法
	+ property
		+ 本质上是特殊类（实现了数据描述符的类）
		+ 优点
			+ 代码更简洁，可读性，可维护性更强
			+ 更好的管理属性的访问
			+ 控制属性访问权限，提高数据安全性
+ 设计模式
	+ SOLID设计原则
		+ 单一责任原则
		+ 开放封闭原则
		+ 里氏替换原则
		+ 依赖倒置原则
		+ 接口分离原则
	+ 单例模式
		+ 对象只存在一个实例
		+ \_\_init\_\_ 和 \_\_new\_\_ 区别
			+ \_\_new\_\_是实例创建之前被调用，返回该实例对象，是静态方法
			+ \_\_init\_\_是实例对象创建完成后调用，是实例方法
			+ \_\_new\_\_先被调用，\_\_init\_\_后被调用
			+ \_\_new\_\_的返回值（实例）将传递给\_\_init\_\_方法的第一个参数，\_\_init\_\_给这个实例设置相关参数
	+ 工厂模式
	+ 元类
		+ 元类是创建类的类，是类的模板
		+ 元类是用来控制如何创建类的，正如类是创建对象的模板一样
		+ 元类是实例为类，正如类的实例是对象
		+ 创建元类的两种方法
			+ class
			+ type
		+ 元类必须继承自type类
	+ mixin模式
		+ 在程序运行过程中，重定义类的继承，既动态继承
+ 动态获取对象的属性和方法
	+ hasattr(obj, attr):
		这个方法用于检查obj是否有一个名为attr的值的属性，返回一个布尔值
	+ getattr(obj, attr):
		调用这个方法将返回obj中名为attr值的属性的值
	+ setattr(obj, attr, val):
		调用这个方法将给obj的名为attr的值的属性赋值为val